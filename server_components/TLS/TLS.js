import { Buffer } from "node:buffer";
import { TLS_Extension_Reader } from "./TLS_components.js";

// TLS 1.3 https://datatracker.ietf.org/doc/html/rfc8446#section-4

// TLS 1.1 https://datatracker.ietf.org/doc/html/rfc4346#section-7.3

export function TLSRedirect(requestObj, socket){

    //send a 307 temporary redirect

    console.log("\nREDIRECTING TO HTTPS: \n\tPORT: 8443");

    Headers = [
        "HTTP/1.1 307",
        "location: https://localhost:8443",
        "vary: Upgrade-Insecure-Requests",
        "Content-Security-Policy: Upgrade-Insecure-Requests",
        "\r\n"
    ].join("\r\n");

    const response = Buffer.from(Headers);

    socket.end(response);

};

export function TLSHandshake(data, socket){

    // TLS 1.2 HMAC AND SUDORANDOM FUNCTION https://datatracker.ietf.org/doc/html/rfc5246#section-5

    // TLS 1.2 RECORD_PROTOCOL https://datatracker.ietf.org/doc/html/rfc5246#section-6

    // TLS 1.2 HANDSHAKING PROTOCOLS https://datatracker.ietf.org/doc/html/rfc5246#section-7
    
    // TLS 1.3 handshake protocol https://datatracker.ietf.org/doc/html/rfc8446#section-4

    /*
    this is from https://datatracker.ietf.org/doc/html/rfc5246#section-6.1
    CONNECTION STATES ----- THIS IS WHERE I NEED TO START -----

          struct {
          ConnectionEnd          entity;
          PRFAlgorithm           prf_algorithm;
          BulkCipherAlgorithm    bulk_cipher_algorithm;
          CipherType             cipher_type;
          uint8                  enc_key_length;
          uint8                  block_length;
          uint8                  fixed_iv_length;
          uint8                  record_iv_length;
          MACAlgorithm           mac_algorithm;
          uint8                  mac_length;
          uint8                  mac_key_length;
          CompressionMethod      compression_algorithm;
          opaque                 master_secret[48];
          opaque                 client_random[32];
          opaque                 server_random[32];
      } SecurityParameters;
    */

    const type = data[0]; // TLS-record type (1 byte)
    const versionMajor = data[1]; // TLS Major version (1 byte)
    const versionMinor = data[2]; // TLS Minor version (1 byte)
    const length = (data[3] * 2 ** 8) + (data[4]); // data/payload/message/fragment length (2 bytes)


    console.log("OUTER FRAME:")

    console.log("\tType:", type);
    console.log(`\tVersion: ${versionMajor}.${versionMinor}`);
    console.log("\tLength:", length);

    switch (type){
        case 20:    // Change scipher spec
            console.log("CONTENT TYPE: Change scipher spec");
            break;
        case 21:    // Alert
            console.log("CONTENT TYPE: Alert");
            break;
        case 22:    // Handshake

            // https://www.rfc-editor.org/rfc/rfc5246#section-7.4

            console.log("\nCONTENT TYPE: Handshake");

            // track byte offset
            let offset = 0;
            // position, for simplicity
            let position = 0;

            // start deconstructing
            const handshakeType = data[5]; // handshake-type
            const handshakeMessageLength = (data[6] * 2 ** 16) + (data[7] * 2 ** 8) + (data[8]); // length of handshake message
            
            let hTypeString = "";               // hTypeString = handshake type, as string
            let clientVersionMajor = 0;         // client major version
            let clientVersionMinor = 0;         // client minor version

            const randomStructure = {
            gmt_unix_time: 0,                   // the clientside time, for random structure. (4 bytes, clientside time in seconds)
            random_bytes: []                    // opaque random bytes, for random structure. (28 bytes, generated by secure random number generator)
            }

            let sessionID_length = 0;           // the length of the session ID. if 0, no session ID (1 byte)
            let sessionID;                      // the session ID (0 -> 32 bytes)

            let ciphersuite_length = 0;         // the length of the ciphersuite (2 bytes)
            let ciphersuite;                    // the ciphersuite (2 -> 2^16-2 bytes)

            let compressionMethods_length = 0;  // the length of the compression methods field (1 byte)
            let compressionMethods;             // the compression methods (1 -> 2^8-1 bytes)

            let extensions_total_length = 0;    // the length of the extensions field (2 bytes)
            let extensions;                     // the extensions (0 -> 2^16-1 bytes)

            let separatedExtensions = {};       // object to contain the separated extensions

            switch(handshakeType){
                case 0:
                    hTypeString = "hello_request";
                    break;
                case 1:
                    // update the handshake Type, String
                    hTypeString = "client_hello";

                    // get client version
                    clientVersionMajor = data[9];
                    clientVersionMinor = data[10];

                    // get the random structure
                    randomStructure.gmt_unix_time = ((data[11] * 2 ** 24)+(data[12] * 2 ** 16)+(data[13] * 2 ** 8)+(data[14]));
                    randomStructure.random_bytes = data.slice(15, 43);

                    // get sessionID_length, and sessionID
                    sessionID_length = data[43];
                    if(sessionID_length > 0){
                        sessionID = data.slice(44, (44 + sessionID_length));
                        offset += sessionID_length;  // Update offset
                    };

                    // get ciphersuite_length and ciphersuite
                    ciphersuite_length = (data[(44 + offset)] << 8) | (data[45 + offset]);
                    position = 46 + offset; // set current position
                    ciphersuite = data.slice(position, (position + ciphersuite_length));
                    offset += ciphersuite_length;   // Update offset

                    // get compression methods
                    compressionMethods_length = data[46 + offset];
                    position = 47 + offset; // set current position
                    compressionMethods = data.slice(position, (position + compressionMethods_length));
                    offset += compressionMethods_length;

                    // check for extensions
                    position = 47 + offset; // set current position
                    if((position + 1) !== 0){

                        extensions_total_length = (data[position] << 8) | (data[(position+1)]);
                        position += 2;  // update position
                        extensions = data.slice(position, position + extensions_total_length);

                    };

                    separatedExtensions = TLS_Extension_Reader(extensions, extensions_total_length);

                    break;
                case 2:
                    hTypeString = "server_hello";
                    break;
                case 11:
                    hTypeString = "certificate";
                    break;
                case 12:
                    hTypeString = "server_key_exchange";
                    break;
                case 13:
                    hTypeString = "certificate_request";
                    break;
                case 14:
                    hTypeString = "server_hello_done";
                    break;
                case 15:
                    hTypeString = "certificate_verify";
                    break;
                case 16:
                    hTypeString = "client_key_exchange";
                    break;
                case 20:
                    hTypeString = "finished";
                    break;
                default:
                    console.error("Unknown Handshake Type:", handshakeType);
                    hTypeString = null;
                    break;
            }
            console.log("\tHandshake type:", handshakeType, `\n\tHandshake type, string: ${hTypeString}`)
            console.log("\tHandshake message length:", handshakeMessageLength);

            if(hTypeString === "client_hello"){
                console.log("\nHANDSHAKE TYPE:", hTypeString);
                console.log(`\tClient version:\t\t\t ${clientVersionMajor}.${clientVersionMinor}`);
                console.log("\tgmt_unix_time:\t\t\t", randomStructure.gmt_unix_time);
                console.log("\trandom_bytes:\t\t\t", randomStructure.random_bytes);
                console.log("\tsession ID length:\t\t", sessionID_length);
                console.log("\tsessionID:\t\t\t", sessionID);
                console.log("\tciphersuite length:\t\t", ciphersuite_length);
                console.log("\tciphersuite:\t\t\t", ciphersuite);
                console.log("\tcompression methods length:\t", compressionMethods_length);
                console.log("\tcompression methods:\t\t", compressionMethods);
                console.log("\textensions length:\t\t", extensions_total_length);
                console.log("\tSeparated Extensions:");
                console.dir(separatedExtensions);
            }
            break;
        case 23:    // Application data
            console.log("CONTENT TYPE: Application data");
            break;
        default:    // Error if not recognized
            console.error("Unrecognized TLS ContentType");
            break;
    };

    socket.state.HTTP_TLS_connection = true;

};